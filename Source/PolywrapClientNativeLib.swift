// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(PolywrapClientNative)
    import PolywrapClientNative
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_polywrap_native_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_polywrap_native_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol FFIBuilderConfigProtocol {
    func getInterfaces() -> [String: [FfiUri]]?
    func getEnvs() -> [String: [UInt8]]?
    func getWrappers() -> [FfiUriWrapper]?
    func getPackages() -> [FfiUriWrapPackage]?
    func getRedirects() -> [String: FfiUri]?
    func getResolvers() -> [FfiUriResolver]?
    func addEnv(uri: FfiUri, env: [UInt8])
    func removeEnv(uri: FfiUri)
    func addInterfaceImplementations(interfaceUri: FfiUri, implementationUris: [FfiUri])
    func addInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri)
    func removeInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri)
    func addWrapper(uri: FfiUri, wrapper: FfiWrapper)
    func removeWrapper(uri: FfiUri)
    func addPackage(uri: FfiUri, package: FfiWrapPackage)
    func removePackage(uri: FfiUri)
    func addRedirect(from: FfiUri, to: FfiUri)
    func removeRedirect(from: FfiUri)
    func addResolver(resolver: FfiUriResolver)
    func addSystemDefaults()
    func addWeb3Defaults()
    func build() -> FfiClient
}

public class FfiBuilderConfig: FFIBuilderConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_polywrap_native_fn_constructor_ffibuilderconfig_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffibuilderconfig(pointer, $0) }
    }

    public func getInterfaces() -> [String: [FfiUri]]? {
        return try! FfiConverterOptionDictionaryStringSequenceTypeFFIUri.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffibuilderconfig_get_interfaces(self.pointer, $0)
                }
        )
    }

    public func getEnvs() -> [String: [UInt8]]? {
        return try! FfiConverterOptionDictionaryStringSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffibuilderconfig_get_envs(self.pointer, $0)
                }
        )
    }

    public func getWrappers() -> [FfiUriWrapper]? {
        return try! FfiConverterOptionSequenceTypeFFIUriWrapper.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffibuilderconfig_get_wrappers(self.pointer, $0)
                }
        )
    }

    public func getPackages() -> [FfiUriWrapPackage]? {
        return try! FfiConverterOptionSequenceTypeFFIUriWrapPackage.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffibuilderconfig_get_packages(self.pointer, $0)
                }
        )
    }

    public func getRedirects() -> [String: FfiUri]? {
        return try! FfiConverterOptionDictionaryStringTypeFFIUri.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffibuilderconfig_get_redirects(self.pointer, $0)
                }
        )
    }

    public func getResolvers() -> [FfiUriResolver]? {
        return try! FfiConverterOptionSequenceTypeFFIUriResolver.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffibuilderconfig_get_resolvers(self.pointer, $0)
                }
        )
    }

    public func addEnv(uri: FfiUri, env: [UInt8]) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_env(self.pointer,
                                                                          FfiConverterTypeFFIUri.lower(uri),
                                                                          FfiConverterSequenceUInt8.lower(env), $0)
            }
    }

    public func removeEnv(uri: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_remove_env(self.pointer,
                                                                             FfiConverterTypeFFIUri.lower(uri), $0)
            }
    }

    public func addInterfaceImplementations(interfaceUri: FfiUri, implementationUris: [FfiUri]) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_interface_implementations(self.pointer,
                                                                                                FfiConverterTypeFFIUri.lower(interfaceUri),
                                                                                                FfiConverterSequenceTypeFFIUri.lower(implementationUris), $0)
            }
    }

    public func addInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_interface_implementation(self.pointer,
                                                                                               FfiConverterTypeFFIUri.lower(interfaceUri),
                                                                                               FfiConverterTypeFFIUri.lower(implementationUri), $0)
            }
    }

    public func removeInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_remove_interface_implementation(self.pointer,
                                                                                                  FfiConverterTypeFFIUri.lower(interfaceUri),
                                                                                                  FfiConverterTypeFFIUri.lower(implementationUri), $0)
            }
    }

    public func addWrapper(uri: FfiUri, wrapper: FfiWrapper) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_wrapper(self.pointer,
                                                                              FfiConverterTypeFFIUri.lower(uri),
                                                                              FfiConverterTypeFFIWrapper.lower(wrapper), $0)
            }
    }

    public func removeWrapper(uri: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_remove_wrapper(self.pointer,
                                                                                 FfiConverterTypeFFIUri.lower(uri), $0)
            }
    }

    public func addPackage(uri: FfiUri, package: FfiWrapPackage) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_package(self.pointer,
                                                                              FfiConverterTypeFFIUri.lower(uri),
                                                                              FfiConverterTypeFFIWrapPackage.lower(package), $0)
            }
    }

    public func removePackage(uri: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_remove_package(self.pointer,
                                                                                 FfiConverterTypeFFIUri.lower(uri), $0)
            }
    }

    public func addRedirect(from: FfiUri, to: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_redirect(self.pointer,
                                                                               FfiConverterTypeFFIUri.lower(from),
                                                                               FfiConverterTypeFFIUri.lower(to), $0)
            }
    }

    public func removeRedirect(from: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_remove_redirect(self.pointer,
                                                                                  FfiConverterTypeFFIUri.lower(from), $0)
            }
    }

    public func addResolver(resolver: FfiUriResolver) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_resolver(self.pointer,
                                                                               FfiConverterTypeFFIUriResolver.lower(resolver), $0)
            }
    }

    public func addSystemDefaults() {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_system_defaults(self.pointer, $0)
            }
    }

    public func addWeb3Defaults() {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffibuilderconfig_add_web3_defaults(self.pointer, $0)
            }
    }

    public func build() -> FfiClient {
        return try! FfiConverterTypeFFIClient.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffibuilderconfig_build(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFFIBuilderConfig: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiBuilderConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBuilderConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiBuilderConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiBuilderConfig {
        return FfiBuilderConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiBuilderConfig) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIBuilderConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiBuilderConfig {
    return try FfiConverterTypeFFIBuilderConfig.lift(pointer)
}

public func FfiConverterTypeFFIBuilderConfig_lower(_ value: FfiBuilderConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIBuilderConfig.lower(value)
}

public protocol FFIClientProtocol {
    func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8]
    func getImplementations(uri: FfiUri) throws -> [FfiUri]
    func getInterfaces() -> [String: [FfiUri]]?
    func getEnvByUri(uri: FfiUri) -> [UInt8]?
    func asInvoker() -> FfiInvoker
    func invokeWrapperRaw(wrapper: FfiWrapper, uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8]
    func loadWrapper(uri: FfiUri, resolutionContext: FfiUriResolutionContext?) throws -> FfiWrapper
    func tryResolveUri(uri: FfiUri, resolutionContext: FfiUriResolutionContext?) throws -> FfiUriPackageOrWrapper
}

public class FfiClient: FFIClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_fficlient(pointer, $0) }
    }

    public func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_fficlient_invoke_raw(self.pointer,
                                                                      FfiConverterTypeFFIUri.lower(uri),
                                                                      FfiConverterString.lower(method),
                                                                      FfiConverterOptionSequenceUInt8.lower(args),
                                                                      FfiConverterOptionSequenceUInt8.lower(env),
                                                                      FfiConverterOptionTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }

    public func getImplementations(uri: FfiUri) throws -> [FfiUri] {
        return try FfiConverterSequenceTypeFFIUri.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_fficlient_get_implementations(self.pointer,
                                                                               FfiConverterTypeFFIUri.lower(uri), $0)
            }
        )
    }

    public func getInterfaces() -> [String: [FfiUri]]? {
        return try! FfiConverterOptionDictionaryStringSequenceTypeFFIUri.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_fficlient_get_interfaces(self.pointer, $0)
                }
        )
    }

    public func getEnvByUri(uri: FfiUri) -> [UInt8]? {
        return try! FfiConverterOptionSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_fficlient_get_env_by_uri(self.pointer,
                                                                              FfiConverterTypeFFIUri.lower(uri), $0)
                }
        )
    }

    public func asInvoker() -> FfiInvoker {
        return try! FfiConverterTypeFFIInvoker.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_fficlient_as_invoker(self.pointer, $0)
                }
        )
    }

    public func invokeWrapperRaw(wrapper: FfiWrapper, uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_fficlient_invoke_wrapper_raw(self.pointer,
                                                                              FfiConverterTypeFFIWrapper.lower(wrapper),
                                                                              FfiConverterTypeFFIUri.lower(uri),
                                                                              FfiConverterString.lower(method),
                                                                              FfiConverterOptionSequenceUInt8.lower(args),
                                                                              FfiConverterOptionSequenceUInt8.lower(env),
                                                                              FfiConverterOptionTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }

    public func loadWrapper(uri: FfiUri, resolutionContext: FfiUriResolutionContext?) throws -> FfiWrapper {
        return try FfiConverterTypeFFIWrapper.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_fficlient_load_wrapper(self.pointer,
                                                                        FfiConverterTypeFFIUri.lower(uri),
                                                                        FfiConverterOptionTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }

    public func tryResolveUri(uri: FfiUri, resolutionContext: FfiUriResolutionContext?) throws -> FfiUriPackageOrWrapper {
        return try FfiConverterTypeFFIUriPackageOrWrapper.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_fficlient_try_resolve_uri(self.pointer,
                                                                           FfiConverterTypeFFIUri.lower(uri),
                                                                           FfiConverterOptionTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }
}

public struct FfiConverterTypeFFIClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiClient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiClient {
        return FfiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiClient) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiClient {
    return try FfiConverterTypeFFIClient.lift(pointer)
}

public func FfiConverterTypeFFIClient_lower(_ value: FfiClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIClient.lower(value)
}

public protocol FFIInvokerProtocol {
    func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8]
    func getImplementations(uri: FfiUri) throws -> [FfiUri]
    func getInterfaces() -> [String: [FfiUri]]?
    func getEnvByUri(uri: FfiUri) -> [UInt8]?
}

public class FfiInvoker: FFIInvokerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffiinvoker(pointer, $0) }
    }

    public func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiinvoker_invoke_raw(self.pointer,
                                                                       FfiConverterTypeFFIUri.lower(uri),
                                                                       FfiConverterString.lower(method),
                                                                       FfiConverterOptionSequenceUInt8.lower(args),
                                                                       FfiConverterOptionSequenceUInt8.lower(env),
                                                                       FfiConverterOptionTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }

    public func getImplementations(uri: FfiUri) throws -> [FfiUri] {
        return try FfiConverterSequenceTypeFFIUri.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiinvoker_get_implementations(self.pointer,
                                                                                FfiConverterTypeFFIUri.lower(uri), $0)
            }
        )
    }

    public func getInterfaces() -> [String: [FfiUri]]? {
        return try! FfiConverterOptionDictionaryStringSequenceTypeFFIUri.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiinvoker_get_interfaces(self.pointer, $0)
                }
        )
    }

    public func getEnvByUri(uri: FfiUri) -> [UInt8]? {
        return try! FfiConverterOptionSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiinvoker_get_env_by_uri(self.pointer,
                                                                               FfiConverterTypeFFIUri.lower(uri), $0)
                }
        )
    }
}

public struct FfiConverterTypeFFIInvoker: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiInvoker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInvoker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiInvoker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiInvoker {
        return FfiInvoker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiInvoker) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIInvoker_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiInvoker {
    return try FfiConverterTypeFFIInvoker.lift(pointer)
}

public func FfiConverterTypeFFIInvoker_lower(_ value: FfiInvoker) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIInvoker.lower(value)
}

public protocol FFIRecursiveUriResolverProtocol {
    func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper
}

public class FfiRecursiveUriResolver: FFIRecursiveUriResolverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(uriResolver: FfiUriResolver) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_polywrap_native_fn_constructor_ffirecursiveuriresolver_new(
                FfiConverterTypeFFIUriResolver.lower(uriResolver), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffirecursiveuriresolver(pointer, $0) }
    }

    public func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper {
        return try FfiConverterTypeFFIUriPackageOrWrapper.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffirecursiveuriresolver_try_resolve_uri(self.pointer,
                                                                                         FfiConverterTypeFFIUri.lower(uri),
                                                                                         FfiConverterTypeFFIInvoker.lower(invoker),
                                                                                         FfiConverterTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }
}

public struct FfiConverterTypeFFIRecursiveUriResolver: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiRecursiveUriResolver

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiRecursiveUriResolver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiRecursiveUriResolver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiRecursiveUriResolver {
        return FfiRecursiveUriResolver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiRecursiveUriResolver) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIRecursiveUriResolver_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiRecursiveUriResolver {
    return try FfiConverterTypeFFIRecursiveUriResolver.lift(pointer)
}

public func FfiConverterTypeFFIRecursiveUriResolver_lower(_ value: FfiRecursiveUriResolver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIRecursiveUriResolver.lower(value)
}

public protocol FFIStaticUriResolverProtocol {
    func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper
}

public class FfiStaticUriResolver: FFIStaticUriResolverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(uriMap: [String: FfiUriPackageOrWrapper]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeFFIError.lift) {
            uniffi_polywrap_native_fn_constructor_ffistaticuriresolver_new(
                FfiConverterDictionaryStringTypeFFIUriPackageOrWrapper.lower(uriMap), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffistaticuriresolver(pointer, $0) }
    }

    public func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper {
        return try FfiConverterTypeFFIUriPackageOrWrapper.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffistaticuriresolver_try_resolve_uri(self.pointer,
                                                                                      FfiConverterTypeFFIUri.lower(uri),
                                                                                      FfiConverterTypeFFIInvoker.lower(invoker),
                                                                                      FfiConverterTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }
}

public struct FfiConverterTypeFFIStaticUriResolver: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiStaticUriResolver

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiStaticUriResolver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiStaticUriResolver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStaticUriResolver {
        return FfiStaticUriResolver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiStaticUriResolver) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIStaticUriResolver_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStaticUriResolver {
    return try FfiConverterTypeFFIStaticUriResolver.lift(pointer)
}

public func FfiConverterTypeFFIStaticUriResolver_lower(_ value: FfiStaticUriResolver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIStaticUriResolver.lower(value)
}

public protocol FFIUriProtocol {
    func authority() -> String
    func path() -> String
    func toStringUri() -> String
}

public class FfiUri: FFIUriProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(authority: String, path: String, uri: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_polywrap_native_fn_constructor_ffiuri_new(
                FfiConverterString.lower(authority),
                FfiConverterString.lower(path),
                FfiConverterString.lower(uri), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffiuri(pointer, $0) }
    }

    public func authority() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuri_authority(self.pointer, $0)
                }
        )
    }

    public func path() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuri_path(self.pointer, $0)
                }
        )
    }

    public func toStringUri() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuri_to_string_uri(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFFIUri: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUri

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUri {
        return FfiUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUri) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIUri_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUri {
    return try FfiConverterTypeFFIUri.lift(pointer)
}

public func FfiConverterTypeFFIUri_lower(_ value: FfiUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIUri.lower(value)
}

public protocol FFIUriPackageOrWrapperProtocol {
    func getKind() -> FfiUriPackageOrWrapperKind
    func asUri() throws -> FfiUri
    func asWrapper() throws -> FfiUriWrapper
    func asPackage() throws -> FfiUriWrapPackage
}

public class FfiUriPackageOrWrapper: FFIUriPackageOrWrapperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffiuripackageorwrapper(pointer, $0) }
    }

    public func getKind() -> FfiUriPackageOrWrapperKind {
        return try! FfiConverterTypeFFIUriPackageOrWrapperKind.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuripackageorwrapper_get_kind(self.pointer, $0)
                }
        )
    }

    public func asUri() throws -> FfiUri {
        return try FfiConverterTypeFFIUri.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiuripackageorwrapper_as_uri(self.pointer, $0)
            }
        )
    }

    public func asWrapper() throws -> FfiUriWrapper {
        return try FfiConverterTypeFFIUriWrapper.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiuripackageorwrapper_as_wrapper(self.pointer, $0)
            }
        )
    }

    public func asPackage() throws -> FfiUriWrapPackage {
        return try FfiConverterTypeFFIUriWrapPackage.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiuripackageorwrapper_as_package(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeFFIUriPackageOrWrapper: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUriPackageOrWrapper

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriPackageOrWrapper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUriPackageOrWrapper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUriPackageOrWrapper {
        return FfiUriPackageOrWrapper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUriPackageOrWrapper) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIUriPackageOrWrapper_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUriPackageOrWrapper {
    return try FfiConverterTypeFFIUriPackageOrWrapper.lift(pointer)
}

public func FfiConverterTypeFFIUriPackageOrWrapper_lower(_ value: FfiUriPackageOrWrapper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIUriPackageOrWrapper.lower(value)
}

public protocol FFIUriResolutionContextProtocol {
    func setResolutionPath(resolutionPath: [String])
    func setHistory(history: [FfiUriResolutionStep])
    func setResolvingUriMap(resolvingUriMap: [String: Bool])
    func setStartResolving(uri: FfiUri)
    func setStopResolving(uri: FfiUri)
    func trackStep(step: FfiUriResolutionStep)
    func getHistory() -> [FfiUriResolutionStep]
    func getResolutionPath() -> [FfiUri]
    func createSubHistoryContext() -> FfiUriResolutionContext
    func createSubContext() -> FfiUriResolutionContext
}

public class FfiUriResolutionContext: FFIUriResolutionContextProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_polywrap_native_fn_constructor_ffiuriresolutioncontext_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffiuriresolutioncontext(pointer, $0) }
    }

    public func setResolutionPath(resolutionPath: [String]) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_set_resolution_path(self.pointer,
                                                                                             FfiConverterSequenceString.lower(resolutionPath), $0)
            }
    }

    public func setHistory(history: [FfiUriResolutionStep]) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_set_history(self.pointer,
                                                                                     FfiConverterSequenceTypeFFIUriResolutionStep.lower(history), $0)
            }
    }

    public func setResolvingUriMap(resolvingUriMap: [String: Bool]) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_set_resolving_uri_map(self.pointer,
                                                                                               FfiConverterDictionaryStringBool.lower(resolvingUriMap), $0)
            }
    }

    public func setStartResolving(uri: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_set_start_resolving(self.pointer,
                                                                                             FfiConverterTypeFFIUri.lower(uri), $0)
            }
    }

    public func setStopResolving(uri: FfiUri) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_set_stop_resolving(self.pointer,
                                                                                            FfiConverterTypeFFIUri.lower(uri), $0)
            }
    }

    public func trackStep(step: FfiUriResolutionStep) {
        try!
            rustCall {
                uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_track_step(self.pointer,
                                                                                    FfiConverterTypeFFIUriResolutionStep.lower(step), $0)
            }
    }

    public func getHistory() -> [FfiUriResolutionStep] {
        return try! FfiConverterSequenceTypeFFIUriResolutionStep.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_get_history(self.pointer, $0)
                }
        )
    }

    public func getResolutionPath() -> [FfiUri] {
        return try! FfiConverterSequenceTypeFFIUri.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_get_resolution_path(self.pointer, $0)
                }
        )
    }

    public func createSubHistoryContext() -> FfiUriResolutionContext {
        return try! FfiConverterTypeFFIUriResolutionContext.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_create_sub_history_context(self.pointer, $0)
                }
        )
    }

    public func createSubContext() -> FfiUriResolutionContext {
        return try! FfiConverterTypeFFIUriResolutionContext.lift(
            try!
                rustCall {
                    uniffi_polywrap_native_fn_method_ffiuriresolutioncontext_create_sub_context(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFFIUriResolutionContext: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUriResolutionContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriResolutionContext {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUriResolutionContext, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUriResolutionContext {
        return FfiUriResolutionContext(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUriResolutionContext) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIUriResolutionContext_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUriResolutionContext {
    return try FfiConverterTypeFFIUriResolutionContext.lift(pointer)
}

public func FfiConverterTypeFFIUriResolutionContext_lower(_ value: FfiUriResolutionContext) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIUriResolutionContext.lower(value)
}

public protocol FFIUriResolverProtocol {
    func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper
}

public class FfiUriResolver: FFIUriResolverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffiuriresolver(pointer, $0) }
    }

    public func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper {
        return try FfiConverterTypeFFIUriPackageOrWrapper.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiuriresolver_try_resolve_uri(self.pointer,
                                                                                FfiConverterTypeFFIUri.lower(uri),
                                                                                FfiConverterTypeFFIInvoker.lower(invoker),
                                                                                FfiConverterTypeFFIUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }
}

public struct FfiConverterTypeFFIUriResolver: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUriResolver

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriResolver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUriResolver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUriResolver {
        return FfiUriResolver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUriResolver) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIUriResolver_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUriResolver {
    return try FfiConverterTypeFFIUriResolver.lift(pointer)
}

public func FfiConverterTypeFFIUriResolver_lower(_ value: FfiUriResolver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIUriResolver.lower(value)
}

public protocol FFIWrapPackageProtocol {
    func createWrapper() throws -> FfiWrapper
}

public class FfiWrapPackage: FFIWrapPackageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(wrapper: IffiWrapPackage) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_polywrap_native_fn_constructor_ffiwrappackage_new(
                FfiConverterCallbackInterfaceIffiWrapPackage.lower(wrapper), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffiwrappackage(pointer, $0) }
    }

    public func createWrapper() throws -> FfiWrapper {
        return try FfiConverterTypeFFIWrapper.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiwrappackage_create_wrapper(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeFFIWrapPackage: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiWrapPackage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWrapPackage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiWrapPackage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiWrapPackage {
        return FfiWrapPackage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiWrapPackage) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIWrapPackage_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiWrapPackage {
    return try FfiConverterTypeFFIWrapPackage.lift(pointer)
}

public func FfiConverterTypeFFIWrapPackage_lower(_ value: FfiWrapPackage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIWrapPackage.lower(value)
}

public protocol FFIWrapperProtocol {
    func invoke(method: String, args: [UInt8]?, env: [UInt8]?, invoker: FfiInvoker) throws -> [UInt8]
}

public class FfiWrapper: FFIWrapperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(wrapper: IffiWrapper) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_polywrap_native_fn_constructor_ffiwrapper_new(
                FfiConverterCallbackInterfaceIffiWrapper.lower(wrapper), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_polywrap_native_fn_free_ffiwrapper(pointer, $0) }
    }

    public func invoke(method: String, args: [UInt8]?, env: [UInt8]?, invoker: FfiInvoker) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFFIError.lift) {
                uniffi_polywrap_native_fn_method_ffiwrapper_invoke(self.pointer,
                                                                   FfiConverterString.lower(method),
                                                                   FfiConverterOptionSequenceUInt8.lower(args),
                                                                   FfiConverterOptionSequenceUInt8.lower(env),
                                                                   FfiConverterTypeFFIInvoker.lower(invoker), $0)
            }
        )
    }
}

public struct FfiConverterTypeFFIWrapper: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiWrapper

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWrapper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiWrapper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiWrapper {
        return FfiWrapper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiWrapper) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFFIWrapper_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiWrapper {
    return try FfiConverterTypeFFIWrapper.lift(pointer)
}

public func FfiConverterTypeFFIWrapper_lower(_ value: FfiWrapper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFFIWrapper.lower(value)
}

public struct FfiUriResolutionStep {
    public var sourceUri: FfiUri
    public var result: FfiUriPackageOrWrapper
    public var description: String?
    public var subHistory: [FfiUriResolutionStep]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sourceUri: FfiUri, result: FfiUriPackageOrWrapper, description: String?, subHistory: [FfiUriResolutionStep]?) {
        self.sourceUri = sourceUri
        self.result = result
        self.description = description
        self.subHistory = subHistory
    }
}

public struct FfiConverterTypeFFIUriResolutionStep: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriResolutionStep {
        return try FfiUriResolutionStep(
            sourceUri: FfiConverterTypeFFIUri.read(from: &buf),
            result: FfiConverterTypeFFIUriPackageOrWrapper.read(from: &buf),
            description: FfiConverterOptionString.read(from: &buf),
            subHistory: FfiConverterOptionSequenceTypeFFIUriResolutionStep.read(from: &buf)
        )
    }

    public static func write(_ value: FfiUriResolutionStep, into buf: inout [UInt8]) {
        FfiConverterTypeFFIUri.write(value.sourceUri, into: &buf)
        FfiConverterTypeFFIUriPackageOrWrapper.write(value.result, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionSequenceTypeFFIUriResolutionStep.write(value.subHistory, into: &buf)
    }
}

public func FfiConverterTypeFFIUriResolutionStep_lift(_ buf: RustBuffer) throws -> FfiUriResolutionStep {
    return try FfiConverterTypeFFIUriResolutionStep.lift(buf)
}

public func FfiConverterTypeFFIUriResolutionStep_lower(_ value: FfiUriResolutionStep) -> RustBuffer {
    return FfiConverterTypeFFIUriResolutionStep.lower(value)
}

public struct FfiUriWrapPackage {
    public var uri: FfiUri
    public var package: IffiWrapPackage

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uri: FfiUri, package: IffiWrapPackage) {
        self.uri = uri
        self.package = package
    }
}

public struct FfiConverterTypeFFIUriWrapPackage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriWrapPackage {
        return try FfiUriWrapPackage(
            uri: FfiConverterTypeFFIUri.read(from: &buf),
            package: FfiConverterCallbackInterfaceIffiWrapPackage.read(from: &buf)
        )
    }

    public static func write(_ value: FfiUriWrapPackage, into buf: inout [UInt8]) {
        FfiConverterTypeFFIUri.write(value.uri, into: &buf)
        FfiConverterCallbackInterfaceIffiWrapPackage.write(value.package, into: &buf)
    }
}

public func FfiConverterTypeFFIUriWrapPackage_lift(_ buf: RustBuffer) throws -> FfiUriWrapPackage {
    return try FfiConverterTypeFFIUriWrapPackage.lift(buf)
}

public func FfiConverterTypeFFIUriWrapPackage_lower(_ value: FfiUriWrapPackage) -> RustBuffer {
    return FfiConverterTypeFFIUriWrapPackage.lower(value)
}

public struct FfiUriWrapper {
    public var uri: FfiUri
    public var wrapper: FfiWrapper

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uri: FfiUri, wrapper: FfiWrapper) {
        self.uri = uri
        self.wrapper = wrapper
    }
}

public struct FfiConverterTypeFFIUriWrapper: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriWrapper {
        return try FfiUriWrapper(
            uri: FfiConverterTypeFFIUri.read(from: &buf),
            wrapper: FfiConverterTypeFFIWrapper.read(from: &buf)
        )
    }

    public static func write(_ value: FfiUriWrapper, into buf: inout [UInt8]) {
        FfiConverterTypeFFIUri.write(value.uri, into: &buf)
        FfiConverterTypeFFIWrapper.write(value.wrapper, into: &buf)
    }
}

public func FfiConverterTypeFFIUriWrapper_lift(_ buf: RustBuffer) throws -> FfiUriWrapper {
    return try FfiConverterTypeFFIUriWrapper.lift(buf)
}

public func FfiConverterTypeFFIUriWrapper_lower(_ value: FfiUriWrapper) -> RustBuffer {
    return FfiConverterTypeFFIUriWrapper.lower(value)
}

public enum FfiError {
    case UriParseError(err: String)
    case RedirectsError(err: String, resolutionStack: [String: String])
    case WrapperError(err: String)
    case WrapperCreateError(err: String)
    case InvokeError(uri: String, method: String, err: String)
    case LoadWrapperError(uri: String, err: String)
    case WasmWrapperError(err: String)
    case ResolutionError(err: String)
    case UriNotFoundError(uri: String)
    case MsgpackError(err: String)
    case ManifestError(err: String)
    case FileReadError(err: String)
    case ResolverError(err: String)
    case PluginError(err: String)
    case RuntimeError(err: String)
    case OtherError(err: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeFFIError.lift(error)
    }
}

public struct FfiConverterTypeFFIError: FfiConverterRustBuffer {
    typealias SwiftType = FfiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .UriParseError(
                err: FfiConverterString.read(from: &buf)
            )
        case 2: return try .RedirectsError(
                err: FfiConverterString.read(from: &buf),
                resolutionStack: FfiConverterDictionaryStringString.read(from: &buf)
            )
        case 3: return try .WrapperError(
                err: FfiConverterString.read(from: &buf)
            )
        case 4: return try .WrapperCreateError(
                err: FfiConverterString.read(from: &buf)
            )
        case 5: return try .InvokeError(
                uri: FfiConverterString.read(from: &buf),
                method: FfiConverterString.read(from: &buf),
                err: FfiConverterString.read(from: &buf)
            )
        case 6: return try .LoadWrapperError(
                uri: FfiConverterString.read(from: &buf),
                err: FfiConverterString.read(from: &buf)
            )
        case 7: return try .WasmWrapperError(
                err: FfiConverterString.read(from: &buf)
            )
        case 8: return try .ResolutionError(
                err: FfiConverterString.read(from: &buf)
            )
        case 9: return try .UriNotFoundError(
                uri: FfiConverterString.read(from: &buf)
            )
        case 10: return try .MsgpackError(
                err: FfiConverterString.read(from: &buf)
            )
        case 11: return try .ManifestError(
                err: FfiConverterString.read(from: &buf)
            )
        case 12: return try .FileReadError(
                err: FfiConverterString.read(from: &buf)
            )
        case 13: return try .ResolverError(
                err: FfiConverterString.read(from: &buf)
            )
        case 14: return try .PluginError(
                err: FfiConverterString.read(from: &buf)
            )
        case 15: return try .RuntimeError(
                err: FfiConverterString.read(from: &buf)
            )
        case 16: return try .OtherError(
                err: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiError, into buf: inout [UInt8]) {
        switch value {
        case let .UriParseError(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)

        case let .RedirectsError(err, resolutionStack):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(err, into: &buf)
            FfiConverterDictionaryStringString.write(resolutionStack, into: &buf)

        case let .WrapperError(err):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(err, into: &buf)

        case let .WrapperCreateError(err):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(err, into: &buf)

        case let .InvokeError(uri, method, err):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(uri, into: &buf)
            FfiConverterString.write(method, into: &buf)
            FfiConverterString.write(err, into: &buf)

        case let .LoadWrapperError(uri, err):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(uri, into: &buf)
            FfiConverterString.write(err, into: &buf)

        case let .WasmWrapperError(err):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(err, into: &buf)

        case let .ResolutionError(err):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(err, into: &buf)

        case let .UriNotFoundError(uri):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(uri, into: &buf)

        case let .MsgpackError(err):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(err, into: &buf)

        case let .ManifestError(err):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(err, into: &buf)

        case let .FileReadError(err):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(err, into: &buf)

        case let .ResolverError(err):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(err, into: &buf)

        case let .PluginError(err):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(err, into: &buf)

        case let .RuntimeError(err):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(err, into: &buf)

        case let .OtherError(err):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(err, into: &buf)
        }
    }
}

extension FfiError: Equatable, Hashable {}

extension FfiError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FfiUriPackageOrWrapperKind {
    case uri
    case package
    case wrapper
}

public struct FfiConverterTypeFFIUriPackageOrWrapperKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiUriPackageOrWrapperKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriPackageOrWrapperKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .uri

        case 2: return .package

        case 3: return .wrapper

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiUriPackageOrWrapperKind, into buf: inout [UInt8]) {
        switch value {
        case .uri:
            writeInt(&buf, Int32(1))

        case .package:
            writeInt(&buf, Int32(2))

        case .wrapper:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFFIUriPackageOrWrapperKind_lift(_ buf: RustBuffer) throws -> FfiUriPackageOrWrapperKind {
    return try FfiConverterTypeFFIUriPackageOrWrapperKind.lift(buf)
}

public func FfiConverterTypeFFIUriPackageOrWrapperKind_lower(_ value: FfiUriPackageOrWrapperKind) -> RustBuffer {
    return FfiConverterTypeFFIUriPackageOrWrapperKind.lower(value)
}

extension FfiUriPackageOrWrapperKind: Equatable, Hashable {}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias UniFFICallbackHandle = UInt64
private class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for IffiUriResolver Callback Interface

public protocol IffiUriResolver: AnyObject {
    func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceIffiUriResolver: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

        func invokeTryResolveUri(_ swiftCallbackInterface: IffiUriResolver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
            var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
            func makeCall() throws -> Int32 {
                let result = try swiftCallbackInterface.tryResolveUri(
                    uri: FfiConverterTypeFFIUri.read(from: &reader),
                    invoker: FfiConverterTypeFFIInvoker.read(from: &reader),
                    resolutionContext: FfiConverterTypeFFIUriResolutionContext.read(from: &reader)
                )
                var writer = [UInt8]()
                FfiConverterTypeFFIUriPackageOrWrapper.write(result, into: &writer)
                out_buf.pointee = RustBuffer(bytes: writer)
                return UNIFFI_CALLBACK_SUCCESS
            }
            do {
                return try makeCall()
            } catch let error as FfiError {
                out_buf.pointee = FfiConverterTypeFFIError.lower(error)
                return UNIFFI_CALLBACK_ERROR
            }
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceIffiUriResolver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: IffiUriResolver
            do {
                cb = try FfiConverterCallbackInterfaceIffiUriResolver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("IFFIUriResolver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeTryResolveUri(cb, argsData, argsLen, out_buf)
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceIffiUriResolver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_polywrap_native_fn_init_callback_iffiuriresolver(foreignCallbackCallbackInterfaceIffiUriResolver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<IffiUriResolver>()
}

extension FfiConverterCallbackInterfaceIffiUriResolver: FfiConverter {
    typealias SwiftType = IffiUriResolver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for IffiWrapPackage Callback Interface

public protocol IffiWrapPackage: AnyObject {
    func createWrapper() throws -> IffiWrapper
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceIffiWrapPackage: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

        func invokeCreateWrapper(_ swiftCallbackInterface: IffiWrapPackage, _: UnsafePointer<UInt8>, _: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
            func makeCall() throws -> Int32 {
                let result = try swiftCallbackInterface.createWrapper(
                )
                var writer = [UInt8]()
                FfiConverterCallbackInterfaceIffiWrapper.write(result, into: &writer)
                out_buf.pointee = RustBuffer(bytes: writer)
                return UNIFFI_CALLBACK_SUCCESS
            }
            do {
                return try makeCall()
            } catch let error as FfiError {
                out_buf.pointee = FfiConverterTypeFFIError.lower(error)
                return UNIFFI_CALLBACK_ERROR
            }
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceIffiWrapPackage.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: IffiWrapPackage
            do {
                cb = try FfiConverterCallbackInterfaceIffiWrapPackage.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("IFFIWrapPackage: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeCreateWrapper(cb, argsData, argsLen, out_buf)
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceIffiWrapPackage {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_polywrap_native_fn_init_callback_iffiwrappackage(foreignCallbackCallbackInterfaceIffiWrapPackage, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<IffiWrapPackage>()
}

extension FfiConverterCallbackInterfaceIffiWrapPackage: FfiConverter {
    typealias SwiftType = IffiWrapPackage
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for IffiWrapper Callback Interface

public protocol IffiWrapper: AnyObject {
    func invoke(method: String, args: [UInt8]?, env: [UInt8]?, invoker: FfiInvoker) throws -> [UInt8]
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceIffiWrapper: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

        func invokeInvoke(_ swiftCallbackInterface: IffiWrapper, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
            var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
            func makeCall() throws -> Int32 {
                let result = try swiftCallbackInterface.invoke(
                    method: FfiConverterString.read(from: &reader),
                    args: FfiConverterOptionSequenceUInt8.read(from: &reader),
                    env: FfiConverterOptionSequenceUInt8.read(from: &reader),
                    invoker: FfiConverterTypeFFIInvoker.read(from: &reader)
                )
                var writer = [UInt8]()
                FfiConverterSequenceUInt8.write(result, into: &writer)
                out_buf.pointee = RustBuffer(bytes: writer)
                return UNIFFI_CALLBACK_SUCCESS
            }
            do {
                return try makeCall()
            } catch let error as FfiError {
                out_buf.pointee = FfiConverterTypeFFIError.lower(error)
                return UNIFFI_CALLBACK_ERROR
            }
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceIffiWrapper.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: IffiWrapper
            do {
                cb = try FfiConverterCallbackInterfaceIffiWrapper.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("IFFIWrapper: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeInvoke(cb, argsData, argsLen, out_buf)
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceIffiWrapper {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_polywrap_native_fn_init_callback_iffiwrapper(foreignCallbackCallbackInterfaceIffiWrapper, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<IffiWrapper>()
}

extension FfiConverterCallbackInterfaceIffiWrapper: FfiConverter {
    typealias SwiftType = IffiWrapper
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFFIUriResolutionContext: FfiConverterRustBuffer {
    typealias SwiftType = FfiUriResolutionContext?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFFIUriResolutionContext.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFFIUriResolutionContext.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeFFIUriResolver: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriResolver]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFFIUriResolver.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFFIUriResolver.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeFFIUriResolutionStep: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriResolutionStep]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFFIUriResolutionStep.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFFIUriResolutionStep.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeFFIUriWrapPackage: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriWrapPackage]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFFIUriWrapPackage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFFIUriWrapPackage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeFFIUriWrapper: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriWrapper]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFFIUriWrapper.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFFIUriWrapper.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionDictionaryStringTypeFFIUri: FfiConverterRustBuffer {
    typealias SwiftType = [String: FfiUri]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringTypeFFIUri.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringTypeFFIUri.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionDictionaryStringSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [String: [UInt8]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionDictionaryStringSequenceTypeFFIUri: FfiConverterRustBuffer {
    typealias SwiftType = [String: [FfiUri]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringSequenceTypeFFIUri.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringSequenceTypeFFIUri.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFFIUri: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUri]

    public static func write(_ value: [FfiUri], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFFIUri.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiUri] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiUri]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFFIUri.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFFIUriResolver: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriResolver]

    public static func write(_ value: [FfiUriResolver], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFFIUriResolver.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiUriResolver] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiUriResolver]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFFIUriResolver.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFFIUriResolutionStep: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriResolutionStep]

    public static func write(_ value: [FfiUriResolutionStep], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFFIUriResolutionStep.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiUriResolutionStep] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiUriResolutionStep]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFFIUriResolutionStep.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFFIUriWrapPackage: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriWrapPackage]

    public static func write(_ value: [FfiUriWrapPackage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFFIUriWrapPackage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiUriWrapPackage] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiUriWrapPackage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFFIUriWrapPackage.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFFIUriWrapper: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriWrapper]

    public static func write(_ value: [FfiUriWrapper], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFFIUriWrapper.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiUriWrapper] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiUriWrapper]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFFIUriWrapper.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringTypeFFIUri: FfiConverterRustBuffer {
    public static func write(_ value: [String: FfiUri], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeFFIUri.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FfiUri] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FfiUri]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeFFIUri.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringTypeFFIUriPackageOrWrapper: FfiConverterRustBuffer {
    public static func write(_ value: [String: FfiUriPackageOrWrapper], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeFFIUriPackageOrWrapper.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FfiUriPackageOrWrapper] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FfiUriPackageOrWrapper]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeFFIUriPackageOrWrapper.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringSequenceUInt8: FfiConverterRustBuffer {
    public static func write(_ value: [String: [UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceUInt8.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [UInt8]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [UInt8]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceUInt8.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringSequenceTypeFFIUri: FfiConverterRustBuffer {
    public static func write(_ value: [String: [FfiUri]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeFFIUri.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [FfiUri]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [FfiUri]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeFFIUri.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func ffiUriFromString(uri: String) throws -> FfiUri {
    return try FfiConverterTypeFFIUri.lift(
        rustCallWithError(FfiConverterTypeFFIError.lift) {
            uniffi_polywrap_native_fn_func_ffi_uri_from_string(
                FfiConverterString.lower(uri), $0
            )
        }
    )
}

public func ffiWrapPackageFromBytecode(bytes: [UInt8]) throws -> FfiWrapPackage {
    return try FfiConverterTypeFFIWrapPackage.lift(
        rustCallWithError(FfiConverterTypeFFIError.lift) {
            uniffi_polywrap_native_fn_func_ffi_wrap_package_from_bytecode(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        }
    )
}

public func ffiWrapperFromBytecode(bytes: [UInt8]) throws -> FfiWrapper {
    return try FfiConverterTypeFFIWrapper.lift(
        rustCallWithError(FfiConverterTypeFFIError.lift) {
            uniffi_polywrap_native_fn_func_ffi_wrapper_from_bytecode(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        }
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_polywrap_native_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_polywrap_native_checksum_func_ffi_uri_from_string() != 38293 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_polywrap_native_checksum_func_ffi_wrap_package_from_bytecode() != 15713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_polywrap_native_checksum_func_ffi_wrapper_from_bytecode() != 49309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuri_authority() != 63131 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuri_path() != 62829 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuri_to_string_uri() != 37950 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiinvoker_invoke_raw() != 3235 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiinvoker_get_implementations() != 32319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiinvoker_get_interfaces() != 12762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiinvoker_get_env_by_uri() != 58467 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiwrapper_invoke() != 45813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiwrappackage_create_wrapper() != 37494 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolver_try_resolve_uri() != 35636 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuripackageorwrapper_get_kind() != 46683 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuripackageorwrapper_as_uri() != 44328 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuripackageorwrapper_as_wrapper() != 15706 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuripackageorwrapper_as_package() != 45254 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffistaticuriresolver_try_resolve_uri() != 56915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffirecursiveuriresolver_try_resolve_uri() != 53470 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_set_resolution_path() != 27482 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_set_history() != 54871 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_set_resolving_uri_map() != 47591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_set_start_resolving() != 59028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_set_stop_resolving() != 16837 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_track_step() != 25517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_get_history() != 29788 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_get_resolution_path() != 24342 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_create_sub_history_context() != 43884 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffiuriresolutioncontext_create_sub_context() != 34008 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_invoke_raw() != 59567 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_get_implementations() != 16080 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_get_interfaces() != 56113 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_get_env_by_uri() != 64263 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_as_invoker() != 21006 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_invoke_wrapper_raw() != 52498 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_load_wrapper() != 26998 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_fficlient_try_resolve_uri() != 38876 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_get_interfaces() != 8767 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_get_envs() != 18233 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_get_wrappers() != 60235 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_get_packages() != 51109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_get_redirects() != 33480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_get_resolvers() != 27455 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_env() != 57230 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_remove_env() != 16340 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_interface_implementations() != 6933 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_interface_implementation() != 25987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_remove_interface_implementation() != 58114 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_wrapper() != 52495 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_remove_wrapper() != 40762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_package() != 28624 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_remove_package() != 12482 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_redirect() != 36453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_remove_redirect() != 17203 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_resolver() != 26092 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_system_defaults() != 27088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_add_web3_defaults() != 5887 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_ffibuilderconfig_build() != 58197 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_constructor_ffiuri_new() != 61584 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_constructor_ffiwrapper_new() != 44179 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_constructor_ffiwrappackage_new() != 41099 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_constructor_ffistaticuriresolver_new() != 59028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_constructor_ffirecursiveuriresolver_new() != 8372 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_constructor_ffiuriresolutioncontext_new() != 39996 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi__checksum_constructor_ffibuilderconfig_new() != 22767 {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
